module Asimov
  module ApiV1
    ##
    # Translates errors which are generated by OpenAI and provided in responses
    # to raised exceptions.  Because OpenAI doesn't currently provide any
    # error-specific codes above and beyond the HTTP return code, this matching
    # process is done by matching against message text which makes it somewhat
    # fragile.
    ##
    class ApiErrorTranslator
      ##
      # This method raises an appropriate Asimov::RequestError
      # subclass if the response corresponds to an HTTP error.
      #
      # @param [HTTParty::Response] resp the response (or fragment) object
      # encapsulating the server response.
      ##
      def self.translate(resp)
        return if resp.code == 200

        match_400(resp)
        match_401(resp)
        match_404(resp)
        match_409(resp)
        match_429(resp)

        raise Asimov::RequestError, error_message(resp)
      end

      # rubocop:disable Naming/VariableNumber
      # rubocop:disable Metrics/MethodLength

      # Prefix for OpenAI error message when an invalid key is provided.
      INVALID_API_KEY_PREFIX = "Incorrect API key provided: ".freeze

      # Prefix for OpenAI error message when an organization cannot be found.
      INVALID_ORGANIZATION_PREFIX = "No such organization: ".freeze
      def self.match_401(resp)
        return unless resp.code == 401

        msg = error_message(resp)
        raise Asimov::InvalidApiKeyError, msg if msg.start_with?(INVALID_API_KEY_PREFIX)
        raise Asimov::InvalidOrganizationError, msg if msg.start_with?(INVALID_ORGANIZATION_PREFIX)

        raise Asimov::AuthorizationError
      end
      private_class_method :match_401
      private_constant :INVALID_API_KEY_PREFIX
      private_constant :INVALID_ORGANIZATION_PREFIX

      # Prefix for OpenAI error message when training file format cannot be validated.
      INVALID_TRAINING_EXAMPLE_PREFIX = "Expected file to have JSONL format with " \
                                        "prompt/completion keys. Missing".freeze
      ADDITIONAL_PROPERTIES_ERROR_PREFIX = "Additional properties are not allowed".freeze
      INVALID_PARAMETER_VALUE_STRING = "' is not one of [".freeze
      INVALID_PARAMETER_VALUE_PREFIX_2 = "Invalid value for ".freeze
      BELOW_MINIMUM_STRING = " is less than the minimum of ".freeze
      ABOVE_MAXIMUM_STRING = " is greater than the maximum of ".freeze
      def self.match_400(resp)
        return unless resp.code == 400

        msg = error_message(resp)

        if msg.start_with?(INVALID_TRAINING_EXAMPLE_PREFIX)
          raise Asimov::InvalidTrainingExampleError,
                msg
        end
        if msg.start_with?(ADDITIONAL_PROPERTIES_ERROR_PREFIX)
          raise Asimov::UnsupportedParameterError,
                msg
        end

        if match_invalid_parameter_value?(msg)
          raise Asimov::InvalidParameterValueError,
                msg
        end

        raise Asimov::RequestError, msg
      end
      private_class_method :match_400
      private_constant :INVALID_TRAINING_EXAMPLE_PREFIX
      private_constant :ADDITIONAL_PROPERTIES_ERROR_PREFIX
      private_constant :INVALID_PARAMETER_VALUE_STRING
      private_constant :INVALID_PARAMETER_VALUE_PREFIX_2
      private_constant :BELOW_MINIMUM_STRING
      private_constant :ABOVE_MAXIMUM_STRING

      def self.match_409(resp)
        return unless resp.code == 409

        raise Asimov::RequestError, error_message(resp)
      end
      private_class_method :match_409

      QUOTA_EXCEEDED_MESSAGE = "You exceeded your current quota".freeze
      RATE_LIMIT_REACHED_MESSAGE = "Rate limit reached".freeze
      ENGINE_OVERLOADED_MESSAGE = "The engine is currently overloaded".freeze
      def self.match_429(resp)
        return unless resp.code == 429

        msg = error_message(resp)

        if msg.start_with?(QUOTA_EXCEEDED_MESSAGE)
          raise Asimov::QuotaExceededError,
                msg
        end

        if msg.start_with?(RATE_LIMIT_REACHED_MESSAGE)
          raise Asimov::RateLimitError,
                msg
        end

        if msg.start_with?(ENGINE_OVERLOADED_MESSAGE)
          raise Asimov::ApiOverloadedError,
                msg
        end

        raise Asimov::TooManyRequestsError, msg
      end
      private_class_method :match_429
      private_constant :QUOTA_EXCEEDED_MESSAGE
      private_constant :RATE_LIMIT_REACHED_MESSAGE
      private_constant :ENGINE_OVERLOADED_MESSAGE

      def self.match_invalid_parameter_value?(msg)
        msg.include?(INVALID_PARAMETER_VALUE_STRING) ||
          msg.include?(BELOW_MINIMUM_STRING) ||
          msg.include?(ABOVE_MAXIMUM_STRING) ||
          msg.start_with?(INVALID_PARAMETER_VALUE_PREFIX_2)
      end
      private_class_method :match_invalid_parameter_value?

      def self.match_404(resp)
        return unless resp.code == 404

        msg = error_message(resp)
        raise Asimov::NotFoundError, msg
      end
      private_class_method :match_404

      # rubocop:enable Naming/VariableNumber
      # rubocop:enable Metrics/MethodLength

      ##
      # Extracts the error message from the API response
      ##
      def self.error_message(resp)
        # This handles fragments which can occur in a streamed download
        pr = resp.respond_to?(:parsed_response) ? resp.parsed_response : JSON.parse(resp)
        return "" unless pr.is_a?(Hash) && pr["error"].is_a?(Hash)

        pr["error"]["message"] || ""
      end
      private_class_method :error_message
    end
  end
end
