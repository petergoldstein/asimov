module Asimov
  module ApiV1
    ##
    # Translates errors which are generated by OpenAI and provided in responses
    # to raised exceptions.  Where available, structured error fields (e.g.
    # the "code" field on 429 responses) are checked first; message text
    # matching is used as a fallback.
    ##
    class ApiErrorTranslator
      ##
      # This method raises an appropriate Asimov::RequestError
      # subclass if the response corresponds to an HTTP error.
      #
      # @param [HTTParty::Response] resp the response (or fragment) object
      # encapsulating the server response.
      ##
      def self.translate(resp)
        return if resp.code == 200

        match_400(resp)
        match_401(resp)
        match_404(resp)
        match_409(resp)
        match_429(resp)
        match_500(resp)
        match_503(resp)

        raise Asimov::RequestError, error_message(resp)
      end

      # rubocop:disable Naming/VariableNumber
      # rubocop:disable Metrics/MethodLength

      # Prefix for OpenAI error message when an invalid key is provided.
      INVALID_API_KEY_PREFIX = "Incorrect API key provided: ".freeze

      # Prefix for OpenAI error message when an organization cannot be found.
      INVALID_ORGANIZATION_PREFIX = "No such organization: ".freeze
      def self.match_401(resp)
        return unless resp.code == 401

        msg = error_message(resp)
        raise Asimov::InvalidApiKeyError, msg if msg.start_with?(INVALID_API_KEY_PREFIX)
        raise Asimov::InvalidOrganizationError, msg if msg.start_with?(INVALID_ORGANIZATION_PREFIX)

        raise Asimov::AuthorizationError
      end
      private_class_method :match_401
      private_constant :INVALID_API_KEY_PREFIX
      private_constant :INVALID_ORGANIZATION_PREFIX

      ADDITIONAL_PROPERTIES_ERROR_PREFIX = "Additional properties are not allowed".freeze
      INVALID_PARAMETER_VALUE_STRING = "' is not one of [".freeze
      INVALID_PARAMETER_VALUE_PREFIX_2 = "Invalid value for ".freeze
      BELOW_MINIMUM_STRING = " is less than the minimum of ".freeze
      ABOVE_MAXIMUM_STRING = " is greater than the maximum of ".freeze
      def self.match_400(resp)
        return unless resp.code == 400

        msg = error_message(resp)

        if msg.start_with?(ADDITIONAL_PROPERTIES_ERROR_PREFIX)
          raise Asimov::UnsupportedParameterError,
                msg
        end

        if match_invalid_parameter_value?(msg)
          raise Asimov::InvalidParameterValueError,
                msg
        end

        raise Asimov::RequestError, msg
      end
      private_class_method :match_400
      private_constant :ADDITIONAL_PROPERTIES_ERROR_PREFIX
      private_constant :INVALID_PARAMETER_VALUE_STRING
      private_constant :INVALID_PARAMETER_VALUE_PREFIX_2
      private_constant :BELOW_MINIMUM_STRING
      private_constant :ABOVE_MAXIMUM_STRING

      def self.match_409(resp)
        return unless resp.code == 409

        raise Asimov::RequestError, error_message(resp)
      end
      private_class_method :match_409

      QUOTA_EXCEEDED_MESSAGE = "You exceeded your current quota".freeze
      RATE_LIMIT_REACHED_MESSAGE = "Rate limit reached".freeze
      ENGINE_OVERLOADED_MESSAGE = "The engine is currently overloaded".freeze
      QUOTA_EXCEEDED_CODE = "insufficient_quota".freeze
      RATE_LIMIT_CODE = "rate_limit_exceeded".freeze
      def self.match_429(resp)
        return unless resp.code == 429

        data = error_data(resp)
        msg = data["message"] || ""
        code = data["code"].to_s

        raise Asimov::QuotaExceededError, msg if quota_exceeded?(code, msg)
        raise Asimov::RateLimitError, msg if rate_limit?(code, msg)
        raise Asimov::ApiOverloadedError, msg if engine_overloaded?(msg)

        raise Asimov::TooManyRequestsError, msg
      end
      private_class_method :match_429
      private_constant :QUOTA_EXCEEDED_MESSAGE
      private_constant :RATE_LIMIT_REACHED_MESSAGE
      private_constant :ENGINE_OVERLOADED_MESSAGE
      private_constant :QUOTA_EXCEEDED_CODE
      private_constant :RATE_LIMIT_CODE

      def self.quota_exceeded?(code, msg)
        code == QUOTA_EXCEEDED_CODE || msg.start_with?(QUOTA_EXCEEDED_MESSAGE)
      end
      private_class_method :quota_exceeded?

      def self.rate_limit?(code, msg)
        code == RATE_LIMIT_CODE || msg.start_with?(RATE_LIMIT_REACHED_MESSAGE)
      end
      private_class_method :rate_limit?

      def self.engine_overloaded?(msg)
        msg.start_with?(ENGINE_OVERLOADED_MESSAGE)
      end
      private_class_method :engine_overloaded?

      def self.match_invalid_parameter_value?(msg)
        msg.include?(INVALID_PARAMETER_VALUE_STRING) ||
          msg.include?(BELOW_MINIMUM_STRING) ||
          msg.include?(ABOVE_MAXIMUM_STRING) ||
          msg.start_with?(INVALID_PARAMETER_VALUE_PREFIX_2)
      end
      private_class_method :match_invalid_parameter_value?

      def self.match_404(resp)
        return unless resp.code == 404

        msg = error_message(resp)
        raise Asimov::NotFoundError, msg
      end
      private_class_method :match_404

      def self.match_500(resp)
        return unless resp.code == 500

        raise Asimov::ServerError, error_message(resp)
      end
      private_class_method :match_500

      def self.match_503(resp)
        return unless resp.code == 503

        raise Asimov::ServiceUnavailableError, error_message(resp)
      end
      private_class_method :match_503

      # rubocop:enable Naming/VariableNumber
      # rubocop:enable Metrics/MethodLength

      def self.error_data(resp)
        pr = resp.respond_to?(:parsed_response) ? resp.parsed_response : JSON.parse(resp)
        return {} unless pr.is_a?(Hash) && pr["error"].is_a?(Hash)

        pr["error"]
      rescue JSON::ParserError
        {}
      end
      private_class_method :error_data

      def self.error_message(resp)
        error_data(resp)["message"] || ""
      end
      private_class_method :error_message
    end
  end
end
